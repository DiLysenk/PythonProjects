#!/usr/bin/env python3

import unittest
import copy

#######################################################################################################################
# Совпадающие концы
# Для заданного списка строк вернуть количество строк,
# таких, что их длина неменьше 2, при этом первый и последний
# символ совпадают
#
# То есть: 'aba' - удовлетворяющая условию строка, 'a' и 'abab' - нет
def match_ends(words):
    p = 0
    for string in words:   # для каждой строки в списке _ - идет как строка
        if len(string) >= 2:
            if string[0] == string[-1]:
                p += 1
    return p



#######################################################################################################################
# Частичная сумма
#
# Для последовательности, заданной аргументом - списком целых чисел вернуть
# новый список из частичных сумм последовательности
def partial_sum(ints):
    par_sum = []
    for integer in ints:
        n = 0
        for i in range(integer + 1):
            n = i + n
        par_sum.append(n)
    return par_sum


#######################################################################################################################
# Велосипед enumerate:
#
# Реализовать стандартную функцию enumerate для списков:
# Для произвольного списка, вернуть новый список, в котором
# содержатся пары (кортеж из двух элементов): индекс значения и само значение
# Пример: [3, 14, 15] -> [(0, 3), (1, 14), (2, 15)]
def list_enumerate(lst):
    enumerate_lst = []
    i = -1

    for integer in lst:

        i += 1
        lst1 = [i, integer]
        enumerate_lst.append(tuple(lst1))
    return enumerate_lst


#######################################################################################################################
# Пересечение
#
# Написать предикат (логическую функцию, возвращающую True или False)
# проверяющий, есть ли в двух списках хотя бы один одинаковый элемент
# Пример: ([0, 1, 2], [3, 4]) -> False
#         ([0, 1, 2], [2, 3]) -> True
def have_same_element(lst1, lst2):
    return len(set(lst1+lst2)) != len(lst1) + len(lst2) # сравним длину  множества суммы  двух списков и сумму элементов двух списков




#######################################################################################################################
# Единичная матрица из списков
#
# Написать функцию, создающую спискок из n-списков, таких что
# Для этого списка lst: lst[i][j] == 0 для всех i != j и
# lst[i][j] == 1 для всех i == j.
# Пример: n = 3 -> [ [1, 0, 0],
#                    [0, 1, 0],
#                    [0, 0, 1] ]
#        
def identity_2d_lists(n):
    a = [] # пустой список для основного результата
    for i in range(n):
        b = []
        for j in range(n):
            if i == j:
                b.append(1)
            else:
                b.append(0)
        a.append(b)
    return a



